  AuroraCluster:
    Type: AWS::RDS::DBCluster
    Properties:
      DBClusterIdentifier: !Sub "${AWS::StackName}-cluster"
      DBClusterParameterGroupName: !Ref AuroraClusterDBParameters
      Engine: aurora-mysql
      # We will usually do engine version updates manually, since updating this requires replacement, so this value may be out of sync with cluster.
      EngineVersion: 5.7.12
      MasterUsername: !Sub "{{resolve:secretsmanager:${DatabaseSecret}:SecretString:username}}"
      MasterUserPassword: !Sub "{{resolve:secretsmanager:${DatabaseSecret}:SecretString:password}}"
      VpcSecurityGroupIds: [!ImportValue VPC-DBSecurityGroup]
      DBSubnetGroupName: !ImportValue VPC-DBSubnetGroup

<% 2.times do |i| %>
  Aurora<%=i%>:
    Type: AWS::RDS::DBInstance
    Properties:
      DBInstanceIdentifier: !Sub "${AWS::StackName}-<%=i%>"
      DBClusterIdentifier: !Ref AuroraCluster
      DBInstanceClass: db.r4.large
      DBSubnetGroupName: !ImportValue VPC-DBSubnetGroup
      Engine: aurora-mysql
      # We will usually do engine version updates manually, so don't specify an EngineVersion for the DBInstance.
<% end -%>

  AuroraClusterDBParameters:
    Type: AWS::RDS::DBClusterParameterGroup
    Properties:
      Description: !Sub "Aurora DB Cluster Parameters for ${AWS::StackName}."
      Family: aurora-mysql5.7
      Parameters: {'innodb_monitor_enable': 'all'}

<% db_secrets = [nil, 'application-writer', 'readonly'].map do |user| -%>
  DatabaseSecret<%=secret = user&.underscore&.camelcase%>:
    Type: AWS::SecretsManager::Secret
    Properties:
      Description: !Sub "Secrets for accessing database<%user ? " user #{user}" : ''%> from ${AWS::StackName} CloudFormation stack"
      GenerateSecretString:
        SecretStringTemplate: !Sub '{"username": "<%=user || '${DatabaseUsername}'%>"}'
        GenerateStringKey: password
        PasswordLength: 10
        ExcludePunctuation: True
      Name: !Sub "CfnStack/${AWS::StackName}/database-<%=user || 'secret'%>"
<% secret; end -%>

<% az_pairs = frontend_azs.each_with_index.map {|az, i| [az, azs.length == 1 ? backup_az : azs[i + 1 % azs.length]]} -%>
  DBProxy:
    Type: AWS::RDS::DBProxy
    Properties:
      DBProxyName: !Ref AWS::StackName
      EngineFamily: MYSQL
      IdleClientTimeout: 14400
      RoleArn: !GetAtt DBProxyRole.Arn
      Auth:
<% db_secrets.each do |secret| -%>
        - {AuthScheme: SECRETS, SecretArn: !Ref DatabaseSecret<%=secret%>, IAMAuth: DISABLED}
<%end -%>
      VpcSubnetIds: <%=subnets(az_pairs.first).to_json%>
      VpcSecurityGroupIds: [!ImportValue VPC-DBSecurityGroup]
  DBProxyRole:
    Type: AWS::IAM::Role
    Properties:
      <%=service_role 'rds'%>
      Policies:
        - PolicyName: RDSProxy
          PolicyDocument:
            Statement:
<% db_secrets.each do |secret| -%>
              - {Effect: Allow, Action: 'secretsmanager:GetSecretValue', Resource: !Ref DatabaseSecret<%=secret%>}
<%end -%>
      PermissionsBoundary: !ImportValue IAM-DevPermissions
  DBProxyTargetGroup:
    Type: AWS::RDS::DBProxyTargetGroup
    DependsOn: [Aurora0, Aurora1]
    Properties:
      DBProxyName: !Ref DBProxy
      DBClusterIdentifiers: [!Ref AuroraCluster]
      TargetGroupName: default
      ConnectionPoolConfigurationInfo:
        ConnectionBorrowTimeout: 10
        MaxIdleConnectionsPercent: 0
        SessionPinningFilters: [EXCLUDE_VARIABLE_SETS]
<% # AZs use separate DBProxyEndpoints to ensure each AZ subnet has a local endpoint.
  az_pairs.product(['ReadOnly', nil]).each do |(az, az2), ro|
  # ReadWrite endpoint for the first AZ is already created as the default endpoint.
  next if az == frontend_azs.first && ro.nil?
-%>
  DBProxy<%="#{az}#{ro}"%>:
    Type: AWS::RDS::DBProxyEndpoint
    Properties:
      DBProxyEndpointName: !Sub "${DBProxy}-<%="#{az}#{ro&.prepend('-')}"%>"
      DBProxyName: !Ref DBProxy
      TargetRole: <%=ro ? 'READ_ONLY' : 'READ_WRITE'%>
      VpcSecurityGroupIds: [!ImportValue VPC-DBSecurityGroup]
      VpcSubnetIds: <%=subnets([az, az2]).to_json %>
<% end -%>
